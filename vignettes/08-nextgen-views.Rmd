---
title: "NextGen Hydrofabric: The power of 'views'"
description: |
  "Multi realization data products from minimal data layers"
author:
  - name: "Mike Johnson"
    url: https://github.com/mikejohnson51
    affiliation: Lynker, NOAA-Affiliate
    affiliation_url: https://lynker.com
  - name: "Justin Singh"
    url: https://github.com/program--
    affiliation: Lynker, NOAA-Affiliate
    affiliation_url: https://lynker.com
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The [NextGen Hydrofabric Data Model](https://noaa-owp.github.io/hydrofabric/articles/04-data-model-deep-dive.html) aims to support a multi-realization
view of the river network and landscape using the concepts outlined in the [OGC HY Features Standard](https://docs.ogc.org/is/14-111r6/14-111r6.html).

The data model we are proposing, and enforcing, is aimed to allow flexible realizations with minimal data I/O. It does this by

  1. Defining a *principle realization*,
  2. Storing multiple layers of data in a self contained data format.
  3. Using opaque identifiers to reference realizations of the same hydrologic unit across layers

## NextGen

The notion of a HY Feature ready hydrofabric requires the ability to access a number of views. This is distinct from the
[reference fabric](02-design-deep-dive.html) which is intended to support the creation of data products that service a range of modeling applications.
In its current state, NextGen requires a few views of a hydrofabric for model execution. This currently includes, but are likely not limited to, the following:

| | Workstream | Realization | Attributes | Example |
| - | ---------- | ----------- | ---------- | ----- |
| 1 | Reporting | Location on River network coincident with features like a gage | `toid` | What is the flow at USGS gage XXX |
| 2 | Routing | Flowpath network  | `id`, `toid` | Moving water from channel to channel | 
| 3 | Rainfall Runoff Modeling | Divide complex **without** geometry | `divide_id`, `id` | Linking divide units to draining flowpath | 
| 4 | Forcing Engine | Divide complex **with** geometry | `divide_id`, `geometry` | Rescale gridded data to units of divide complex | 

Here, we will show that the hydrofabric data model supports ALL of these views through clear examples that include the derivation process.

## Background

1. NextGen uses a `flowpath` --> `nexus` topology. This is a requirement of aggregating the divide complex to the desired
   spatial scale while avoiding a `many:1` `flowline` to `divide` relation.
   > In possible upcoming work with GID and FIM, we may relax that constraint by building out a `flowline` layer that would
   > allow a `many:1` relationship _and_ a higher resolution flowline network. Such a step might also allow for a
   > `fp` --> `fp` topology that is more consistent with the core of [t-route](https://github.com/NOAA-OWP/t-route).
   > Until that time, water flows from a flowpath to a nexus, and more then one flowpath may contribute to any one nexus.

2. The need to store many representations of the hydrologic landscape, both spatially and aspatially. In the spatial community,
   a key way to store many different data layers (or _tables_), either spatial or aspatial, in a single database is
   the [OGC GeoPackage Format]((https://www.geopackage.org/)), which provides a standard for spatial information
   on top of SQLite databases.

3. While the hydrofabric identifiers are prefixed to make them human-readable, they should
   **not** be parsed within code to infer something more.

4. These are the R based libraries that will be used in this example. All of them have Python or other language equivalents.

```{r, message = FALSE}
library(sf)      # spatial data access and manipulation
library(mapview) # interactive map creation
library(arrow)   # parquet read/write
library(dplyr)   # SQL syntax on data.frames

#> Some (R -> Python) equivalents for these packages are:
#> - sf      -> geopandas/shapely/fiona
#> - mapview -> folium
#> - arrow   -> pyarrow
#> - dplyr   -> pandas/polars
```

## NextGen Principle Realization

Due to the routing requirements of NextGen (View #3), the connectivity of the flowpath network is the _principle view_ of the
landscape and thus the primary realization of any hydrologic unit. It is because of this that the flowpath realization and
identification is given the ultimate `id` identifier. Anywhere that `id` is found in the HF GeoPackages, it is in reference
to our **principle realization** - that of flowpaths.

Alternatively, it is possible to consider the hydrofabric with a different perspective, which we describe as a **viewed realization**.
A viewed realization is in essence, another representation of the hydrofabric, or another abstraction over the underlying data.

In particular, a viewed realization that must be considered, due to its use-cases, is the divide complex realization, in which the
divide realization is considered the primary realization of any hydrologic unit. However, understand that _any viewed realization_
is derived from the principle realization, and the principle realization remains the primary realization for hydrologic units.

Following from this, the divide realization of flowpaths are uniquely identified by a `divide_id`. There ARE instances where
a divide does not have a draining flowpath, thus those divides have a corresponding `id` property equal to `NA`.
These can be removed using the `has_flowline` boolean flag property if desired, as they are NOT part of the dendritic system.

## Build a subset

We will use NWIS location `Gages=06752260` that sits on the Cache La Poudre River in Fort Collins, Colorado.
The USGS Next Generation Monitoring Location Page for this site is [here](https://waterdata.usgs.gov/monitoring-location/06752260/)
and the Geoconnex PID can be found [here](https://reference.geoconnex.us/collections/gages/items?provider_id=06752260)

To help with this example, we create a cutout of the Poudre River Basin using the hydrofabric subsetter found [here](https://github.com/LynkerIntel/hfsubset)
  
```bash
mkdir poudre
cd poudre

hfsubset -l divides,nexus,flowpaths,flowpath_attributes,hydrolocations \
         -o ./poudre-subset.gpkg \
         -r "pre-release" \
         -t hl \
         "Gages-06752260"
```

### Did we create it?

```{r}
(f = list.files("poudre", pattern = ".gpkg", full.names = TRUE))
```

### Whats in it?

```{r}
st_layers(f)
```


### Lets map it! 

```{r, echo = FALSE}
knitr::include_graphics("../man/figures/hydrofabric.png")
```


# Forcing (Task 1)

To generate the forcing mesh (currently using EMSF) the forcing workstream needs the divide complex geometries and associated
`divide_id` of each unit. These can be pulled directly from the `divides` layer and are ready to go!

```{r}
read_sf(f, "divides") %>% 
  select(divide_id)
```


# Rainfall Runoff Modeling (Task 2)

The rainfall runoff modeling requires the ability to identify a unit of the divide complex, and its associated draining flowpath.
From this, configuration files can be used to assign model formulations that the model engine orchestrates to operate on as a single "model".

In this case, the _viewed_ realization is the divide complex, but the _principle_ realization remains the flowpath network.
Since we are not interested in geometries, we drop the geometry column. 

> Had we used SQLite directly to access this layer, rather than `sf`, we could have avoided reading the geometry column entirely.

```{r}
read_sf(f, "divides") %>%
  select(divide_id, id) %>%
  st_drop_geometry()
```

## Working across model formulations

Once divides are located, and models assigned, there is often a need to populate the model with some pre-computed information or attributes.
One example is [NOAH OWP Modular model](https://github.com/NOAA-OWP/noah-owp-modular) and [CFE model](https://github.com/NOAA-OWP/cfe) which
requires a suite of divide-summarized data. This data, lives adjacent to the core hydrofabric data but can be accessed using a set of `divide_id`.

For example, lets say we wanted CFE and NOAH OWP data for `cat-280570`:

```{r}
open_dataset("s3://nextgen-hydrofabric/pre-release/nextgen_10L_cfe_noahowp.parquet") %>%
  filter(divide_id == "cat-280570") %>%
  collect()
```

# Routing (Task 3)

Routing is based on the flowpath to nexus connection described in the assumptions and requires water to move from flowpaths, into nexuses, into flowpaths. 

More then one flowpath can contribute to a nexus, but only one nexus can contribute to a flowpath.

The flowpath topology can be extracted from the divides layer!

```{r}
(network = read_sf(f, "divides") %>%
  select(divide_id, id, toid) %>%
  st_drop_geometry())
```

A hard requirement of `ngen` is that the network remains dendritic (e.g a [DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph)).
We can ensure that the resultant flowpath topology, extracted from the divide realization, is compliant:

```{r}
select(network, id, toid) %>%
    igraph::graph_from_data_frame(directed = TRUE) %>%
    igraph::is.dag()
```

Much like the NOAH-OWP/CFE example, knowing the connectivity of the flowpath network is half of the challenge. To successful route water, a range of flowpath attributes needs to be supplied. Currently, these are provided within the flowpath_attributes layer of the hydrofabric data model:

```{r}
read_sf("poudre/poudre-subset.gpkg", "flowpath_attributes") %>%
  filter(id %in% network$id) %>%
  right_join(network)
```

The `id` can be used to extract the complete/partial `flowpath` layer if and when a flowpath geometry is needed:

```{r}
read_sf(f, "flowpaths") %>% 
  filter(id == 'wb-280570') %>%
   mapview()
```

# Reporting (Task 3)

The last task is one that is NOT actually well facilitated by the existing NWM and that is how do you find the locations of know Points of interest,

For example, lets say we wanted to find the USGS gages present in the Poudre Basin. To do this we could search the hydrolocations for instances of type `Gages`.

```{r}
(gages = read_sf(f, "hydrolocations") %>%
   filter(hl_reference == "Gages"))
```

Note that the `id` of the hydrolocations is the `toid` in the flow network topology!

In total there are `r nrow(gages)` gages found in the Poudre River basin. If we want to view these, and their contributing flowpaths and divides, we simply need to walk across layers:

```{r}
(net = read_sf(f, "divides") %>%
   filter(toid %in% gages$id))
```

```{r}
(fps = read_sf(f, "flowpaths") %>%
   filter(id %in% net$id))
```

```{r, echo = FALSE}
mapview() + gages + net + fps
```

# Conclusion

While there are many layers presented with a hydrofabric, all views needed can be found in the divides layer. This supplies everything needed to run ngen from start to finish, and allow introspection of the results!

It is able to do this through a clear implementation of HY Features concepts, within a detailed yet flexible data model. Taking advantage of this requires an understanding that:

  (1) the principle view of the data set is the flowpath network due to the topology requirements of both ngen and t-route ,
  (2) viewing the divide "view" of the data still provides the ability to access the flowpath and nexus realizations by their identifiers,
  (3) auxiliary data can be built in relation to the appropriate realization (e.g. id, or divide_id) providing the ability for a larger data system to scaffold.

